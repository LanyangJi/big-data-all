package cn.jly.bigdata.flink_advanced.datastream.c14_async_io;

import lombok.SneakyThrows;

/**
 * 在与外部系统交互时（例如，使用存储在数据库中的数据丰富流事件时），需要注意与外部系统的通信延迟不会影响流应用程序的总工作。
 * 天真地访问外部数据库中的数据，例如在 MapFunction 中，通常意味着同步交互：向数据库发送请求，MapFunction 等待直到收到响应。在许多情况下，这种等待占了函数时间的绝大部分。
 * 与数据库的异步交互意味着单个并行函数实例可以并发处理多个请求并同时接收响应。这样，等待时间可以与发送其他请求和接收响应重叠。至少，等待时间可以在多个请求中分摊。这在大多数情况下会导致更高的流吞吐量。
 *
 * 注意：在某些情况下，仅通过将 MapFunction 扩展到非常高的并行度来提高吞吐量也是可能的，但通常会带来非常高的资源成本：拥有更多的并行 MapFunction 实例意味着更多的任务、线程、Flink 内部网络连接，到数据库的网络连接、缓冲区和一般内部簿记开销。
 *
 *如上一节所示，对数据库（或键/值存储）实施适当的异步 I/O 需要该数据库的客户端支持异步请求。许多流行的数据库都提供这样的客户端。
 * 在没有这样的客户端的情况下，可以通过创建多个客户端并使用线程池处理同步调用来尝试将同步客户端变成有限并发客户端。但是，这种方法通常不如适当的异步客户端有效。
 *
 * Flink 的 Async I/O API 允许用户使用带有数据流的异步请求客户端。 API 处理与数据流的集成，以及处理顺序、事件时间、容错等。
 * 假设目标数据库有一个异步客户端，需要三个部分来实现对数据库的异步 I/O 流转换：
 * 调度请求的 AsyncFunction 的实现
 * 获取操作结果并将其传递给 ResultFuture 的回调
 * 在 DataStream 上应用异步 I/O 操作作为转换
 * 以下代码示例说明了基本模式：
 *
 * 
 * @author jilanyang
 * @date 2021/9/1 20:10
 */
public class D01_AsyncIO {
    @SneakyThrows
    public static void main(String[] args) {

    }
}
